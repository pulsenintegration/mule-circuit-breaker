/**
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 **/

/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.mulesoft.mule.devkit.circuitbreaker;

import static org.mule.api.config.MuleProperties.OBJECT_STORE_DEFAULT_PERSISTENT_NAME;

import java.util.Date;
import java.util.concurrent.Semaphore;

import javax.inject.Inject;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mule.api.MuleContext;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Payload;
import org.mule.api.context.MuleContextAware;
import org.mule.api.store.ObjectStore;
import org.mule.api.store.ObjectStoreManager;
import org.mule.message.ExceptionMessage;

/**
 * A module that implements the circuit breaker pattern
 *
 * @author Gerald Loeffler
 * @author Adam Davis
 * @author John D'Emic
 * 
 */
@Module(name = "circuitbreaker", schemaVersion = "0.0.1-SNAPSHOT")
public class CircuitBreakerModule implements MuleContextAware {

	private static final Log LOG = LogFactory.getLog(CircuitBreakerModule.class);

	/**
	 * The amount of failures (exceptions) until the circuit breaker is tripped.
	 */
	@Configurable
	private int tripThreshold;

	/**
	 * How long to wait (in milliseconds) until the breaker is automatically reset.
	 */
	@Configurable
	private long tripTimeout;

	/**
	 * The name of this breaker.
	 */
	@Configurable
	private String breakerName;

	private Date breakerTrippedOn;

	private Semaphore objectStoreMutex = new Semaphore(1);

	private MuleContext muleContext;

	@Inject
	private ObjectStoreManager objectStoreManager;

	public void setTripThreshold(int tripThreshold) {
		this.tripThreshold = tripThreshold;
	}

	public int getTripThreshold() {
		return tripThreshold;
	}

	public void setTripTimeout(long tripTimeout) {
		this.tripTimeout = tripTimeout;
	}

	public long getTripTimeout() {
		return tripTimeout;
	}

	public void setBreakerName(String breakerName) {
		this.breakerName = breakerName;
	}

	public String getBreakerName() {
		return breakerName;
	}

	public void setMuleContext(MuleContext muleContext) {
		this.muleContext = muleContext;
	}

	public MuleContext getMuleContext() {
		return muleContext;
	}

	public void setObjectStoreManager(ObjectStoreManager objectStoreManager) {
		this.objectStoreManager = objectStoreManager;
	}

	public ObjectStoreManager getObjectStoreManager() {
		return objectStoreManager;
	}

	/**
	 * Custom processor
	 * <p/>
	 * {@sample.xml ../../../doc/CircuitBreaker-connector.xml.sample circuitbreaker:filter}
	 *
	 * @param payload
	 *            The message payload
	 * @return Some string
	 * @throws CircuitOpenException
	 *             This exception is thrown once the circuit is tripped
	 */
	@Processor
	public Object filter(@Payload Object payload) throws CircuitOpenException {
		LOG.debug("circuitbeaker:filter applied");

		if (tooFewFailuresToTrip()) {
			LOG.debug("circuitbeaker:filter - failure count too low");
			return payload;
		}

		if (isOpenButTimeoutExceeded()) {
			LOG.debug("circuitbeaker:filter - failure count exceeds threashold but timeout exceeded, count reset");
			breakerTrippedOn = null;
			resetFailureCount();
			return payload;
		}

		LOG.debug("circuitbreaker:filter ACTIVATED");
		throw new CircuitOpenException();
	}

	private boolean tooFewFailuresToTrip() {
		return getFailureCount() < tripThreshold;
	}

	private boolean isOpenButTimeoutExceeded() {
		return breakerTrippedOn != null && timeoutExceeded();
	}

	private boolean timeoutExceeded() {
		return System.currentTimeMillis() - breakerTrippedOn.getTime() > tripTimeout;
	}

	/**
	 * Custom processor
	 * <p/>
	 * {@sample.xml ../../../doc/CircuitBreaker-connector.xml.sample circuitbreaker:trip}
	 *
	 * @param exceptionMessage
	 *            The exception.
	 * @param tripOnException
	 *            The exception type we should trip on.
	 * @return Some string
	 */
	@Processor
	public Object trip(String tripOnException, @Payload ExceptionMessage exceptionMessage) {
		LOG.debug("trip triggered [" + exceptionMessage.getException().getCause().getClass().getCanonicalName() + "] ["
				+ exceptionMessage.getException() + "] comparing to [" + tripOnException + "]");
		if (exceptionMatches(exceptionMessage, tripOnException)) {
			LOG.debug("trip matched to: " + tripOnException);
			incrementFailureCount();
			if (tipThresholdReached()) {
				LOG.debug("failure count matches trip threshold [" + tripThreshold + "]");
				breakerTrippedOn = new Date();
			}
		}
		return exceptionMessage;
	}

	private boolean tipThresholdReached() {
		return getFailureCount() >= tripThreshold;
	}

	/**
	 * Validate that the exception message configured is a super class of the exception that has been thrown
	 */
	private boolean exceptionMatches(ExceptionMessage exceptionMessage, String tripOnException) {
		try {
			final Class<?> tripOn = Class.forName(tripOnException);
			LOG.debug("trip class to match: " + tripOn);
			final Class<? extends Throwable> cause = exceptionMessage.getException().getCause().getClass();
			LOG.debug("trip cause: " + cause);
			return tripOn.isAssignableFrom(cause); // was: cause.getCanonicalName().equals(tripOnException);
		} catch (ClassNotFoundException e) {
			throw new IllegalArgumentException(tripOnException + " is not a valid class", e);
		}
	}

	/**
	 * Return the number of exception of the configured type that have been thrown.
	 */
	private Integer getFailureCount() {
		final String key = failureCountKey();

		final ObjectStore<Integer> store = getAndLockObjectStore();
		try {
			Integer failureCount = 0;
			try {
				if (store.contains(key)) {
					failureCount = store.retrieve(key);
				}
			} catch (Exception e) {
				LOG.error("Could not retrieve key from object-store: " + key, e);
			}
			return failureCount;
		} finally {
			releaseObjectStore();
		}
	}

	/**
	 * Increment the number of failures count when the configured exception is hit.
	 */
	private void incrementFailureCount() {
		final String key = failureCountKey();

		final ObjectStore<Integer> store = getAndLockObjectStore();
		try {
			Integer failureCount = 0;
			if (store.contains(key)) {
				failureCount = store.retrieve(key);
				store.remove(key);
			}
			store.store(key, failureCount + 1);
		} catch (Exception e) {
			LOG.error("Could not manipulate key in object-store: " + key, e);
		} finally {
			releaseObjectStore();
		}
	}

	/**
	 * Reset the exception count after the circuitbreaker is reset
	 */
	void resetFailureCount() {
		final String key = failureCountKey();

		final ObjectStore<Integer> objectStore = getAndLockObjectStore();
		try {
			if (objectStore.contains(key)) {
				objectStore.remove(key);
			}
			objectStore.store(key, 0);
		} catch (Exception e) {
			LOG.error("Could not remove/store key in object-store: " + key, e);
		} finally {
			releaseObjectStore();
		}
	}

	private ObjectStore<Integer> getAndLockObjectStore() {
		acquireObjectStoreMutex();

		return objectStoreManager.<ObjectStore<Integer>> getObjectStore(OBJECT_STORE_DEFAULT_PERSISTENT_NAME);
	}

	private void acquireObjectStoreMutex() {
		try {
			objectStoreMutex.acquire();
		} catch (InterruptedException e) {
			LOG.error("Could not acquire mutex", e);
			throw new RuntimeException("Could not acquire mutex", e);
		}
	}

	private void releaseObjectStore() {
		objectStoreMutex.release();
	}

	private String failureCountKey() {
		return String.format("%s.failureCount", breakerName);
	}
}